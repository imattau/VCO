# VCO Bootstrap Relay Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a production-ready VCO Bootstrap Relay server that validates and stores envelopes, runs sync reconciliation with peers, enforces PoW backpressure, and routes peers via Kad-DHT.

**Architecture:** Single `packages/vco-relay` package composing `@vco/vco-core`, `@vco/vco-sync`, `@vco/vco-transport`. Internal modules: `config`, `store`, `admission`, `sync-handler`, `server`, `main`. Exported via `index.ts` for testability.

**Tech Stack:** TypeScript ESM, LevelDB (`classic-level`), libp2p 2.x, `@libp2p/kad-dht`, `@libp2p/identify`, vitest.

**Design doc:** `docs/plans/2026-02-24-vco-relay-design.md`

**Reference files before starting:**
- `packages/vco-sync/src/pow-policy.ts` — PowChallengePolicy API
- `packages/vco-sync/src/envelope-admission.ts` — admitInboundEnvelope
- `packages/vco-transport/src/libp2p.ts` — existing libp2p setup
- `packages/vco-core/src/zkp.ts` — VCOCore class
- `packages/vco-core/src/protobuf.ts` — encodeEnvelopeProto / decodeEnvelopeProto

---

### Task 1: Package scaffold

**Files:**
- Create: `packages/vco-relay/package.json`
- Create: `packages/vco-relay/tsconfig.json`
- Create: `packages/vco-relay/tsconfig.build.json`
- Create: `packages/vco-relay/src/index.ts` (empty placeholder)

**Step 1: Create `packages/vco-relay/package.json`**

```json
{
  "name": "@vco/vco-relay",
  "version": "0.1.0",
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "bin": {
    "vco-relay": "dist/main.js"
  },
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    }
  },
  "scripts": {
    "build": "tsc -p tsconfig.build.json",
    "typecheck": "tsc -p tsconfig.build.json --noEmit",
    "test": "vitest run",
    "clean": "rm -rf dist .tsbuildinfo"
  },
  "dependencies": {
    "@libp2p/identify": "^3.0.0",
    "@libp2p/kad-dht": "^14.0.0",
    "@vco/vco-core": "0.1.0",
    "@vco/vco-sync": "0.1.0",
    "@vco/vco-transport": "0.1.0",
    "classic-level": "^1.4.1",
    "libp2p": "^2.10.0",
    "multiformats": "^13.4.2"
  }
}
```

**Step 2: Create `packages/vco-relay/tsconfig.json`**

```json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "rootDir": "src",
    "outDir": "dist"
  },
  "include": ["src", "test"]
}
```

**Step 3: Create `packages/vco-relay/tsconfig.build.json`**

```json
{
  "extends": "./tsconfig.json",
  "exclude": ["test"]
}
```

**Step 4: Create empty `packages/vco-relay/src/index.ts`**

```ts
// exports added as modules are implemented
```

**Step 5: Install dependencies**

```bash
cd /path/to/VCO && npm install
```

Expected: no errors, `classic-level` and `@libp2p/kad-dht` appear in `node_modules`.

**Step 6: Verify typecheck passes on empty package**

```bash
npm run typecheck --workspace=packages/vco-relay
```

Expected: PASS (no source to check yet).

**Step 7: Commit**

```bash
git add packages/vco-relay/
git commit -m "Add vco-relay package scaffold"
```

---

### Task 2: Config module

**Files:**
- Create: `packages/vco-relay/src/config.ts`
- Create: `packages/vco-relay/test/config.test.ts`

**Step 1: Write failing test**

```ts
// packages/vco-relay/test/config.test.ts
import { describe, it, expect, beforeEach, afterEach } from "vitest";
import { loadConfig, type RelayConfig } from "../src/config.js";
import { writeFileSync, mkdtempSync, rmSync } from "node:fs";
import { join } from "node:path";
import { tmpdir } from "node:os";

let tmpDir: string;
beforeEach(() => { tmpDir = mkdtempSync(join(tmpdir(), "vco-relay-config-")); });
afterEach(() => { rmSync(tmpDir, { recursive: true }); });

describe("loadConfig", () => {
  it("returns defaults when no file or env vars", () => {
    const config = loadConfig({ configPath: undefined, env: {} });
    expect(config.listenAddrs).toEqual(["/ip4/0.0.0.0/udp/4001/quic-v1"]);
    expect(config.maxConnections).toBe(256);
    expect(config.pow.defaultDifficulty).toBe(0);
    expect(config.pow.maxDifficulty).toBe(20);
    expect(config.pow.windowSeconds).toBe(3600);
    expect(config.maxStoreSizeMb).toBe(0);
  });

  it("loads from JSON file", () => {
    const cfgPath = join(tmpDir, "relay.json");
    writeFileSync(cfgPath, JSON.stringify({ maxConnections: 64 }));
    const config = loadConfig({ configPath: cfgPath, env: {} });
    expect(config.maxConnections).toBe(64);
  });

  it("env vars override file values", () => {
    const cfgPath = join(tmpDir, "relay.json");
    writeFileSync(cfgPath, JSON.stringify({ maxConnections: 64 }));
    const config = loadConfig({
      configPath: cfgPath,
      env: { VCO_MAX_CONNECTIONS: "128" },
    });
    expect(config.maxConnections).toBe(128);
  });

  it("throws on invalid maxConnections", () => {
    expect(() => loadConfig({ configPath: undefined, env: { VCO_MAX_CONNECTIONS: "abc" } }))
      .toThrow();
  });
});
```

**Step 2: Run test to verify it fails**

```bash
npx vitest run packages/vco-relay/test/config.test.ts 2>&1 | tail -20
```

Expected: FAIL — `loadConfig` not found.

**Step 3: Implement `packages/vco-relay/src/config.ts`**

```ts
import { readFileSync } from "node:fs";

export interface RelayPowConfig {
  defaultDifficulty: number;
  maxDifficulty: number;
  windowSeconds: number;
}

export interface RelayConfig {
  listenAddrs: string[];
  dataDir: string;
  maxConnections: number;
  pow: RelayPowConfig;
  maxStoreSizeMb: number;
}

const DEFAULTS: RelayConfig = {
  listenAddrs: ["/ip4/0.0.0.0/udp/4001/quic-v1"],
  dataDir: "./relay-data",
  maxConnections: 256,
  pow: { defaultDifficulty: 0, maxDifficulty: 20, windowSeconds: 3600 },
  maxStoreSizeMb: 0,
};

function assertPositiveInt(value: number, name: string): void {
  if (!Number.isInteger(value) || value < 0) {
    throw new Error(`${name} must be a non-negative integer, got ${value}`);
  }
}

function parseEnvOverrides(env: Record<string, string | undefined>, config: RelayConfig): RelayConfig {
  const out = structuredClone(config);
  if (env.VCO_LISTEN_ADDRS) out.listenAddrs = env.VCO_LISTEN_ADDRS.split(",").map((s) => s.trim());
  if (env.VCO_DATA_DIR) out.dataDir = env.VCO_DATA_DIR;
  if (env.VCO_MAX_CONNECTIONS) {
    const v = Number(env.VCO_MAX_CONNECTIONS);
    assertPositiveInt(v, "VCO_MAX_CONNECTIONS");
    out.maxConnections = v;
  }
  if (env.VCO_POW_DEFAULT_DIFFICULTY) {
    out.pow.defaultDifficulty = Number(env.VCO_POW_DEFAULT_DIFFICULTY);
  }
  if (env.VCO_POW_MAX_DIFFICULTY) {
    out.pow.maxDifficulty = Number(env.VCO_POW_MAX_DIFFICULTY);
  }
  if (env.VCO_MAX_STORE_SIZE_MB) {
    out.maxStoreSizeMb = Number(env.VCO_MAX_STORE_SIZE_MB);
  }
  return out;
}

export interface LoadConfigOptions {
  configPath: string | undefined;
  env: Record<string, string | undefined>;
}

export function loadConfig(options: LoadConfigOptions): RelayConfig {
  let config: RelayConfig = structuredClone(DEFAULTS);
  if (options.configPath) {
    const raw = JSON.parse(readFileSync(options.configPath, "utf8")) as Partial<RelayConfig>;
    config = { ...config, ...raw, pow: { ...config.pow, ...(raw.pow ?? {}) } };
  }
  config = parseEnvOverrides(options.env, config);
  assertPositiveInt(config.maxConnections, "maxConnections");
  return config;
}
```

**Step 4: Run test to verify it passes**

```bash
npx vitest run packages/vco-relay/test/config.test.ts 2>&1 | tail -10
```

Expected: PASS (4 tests).

**Step 5: Export from index.ts**

Add to `packages/vco-relay/src/index.ts`:
```ts
export * from "./config.js";
```

**Step 6: Commit**

```bash
git add packages/vco-relay/src/config.ts packages/vco-relay/src/index.ts packages/vco-relay/test/config.test.ts
git commit -m "Add relay config module with JSON + env var loading"
```

---

### Task 3: Store module (LevelDB)

**Files:**
- Create: `packages/vco-relay/src/store.ts`
- Create: `packages/vco-relay/test/store.test.ts`

**Step 1: Write failing tests**

```ts
// packages/vco-relay/test/store.test.ts
import { describe, it, expect, beforeEach, afterEach } from "vitest";
import { LevelDBRelayStore } from "../src/store.js";
import { mkdtempSync, rmSync } from "node:fs";
import { join } from "node:path";
import { tmpdir } from "node:os";
import { createEnvelope, type VcoEnvelope } from "../../vco-core/src/index.js";
import { NobleCryptoProvider, deriveEd25519Multikey } from "../../vco-crypto/src/index.js";
import { MULTICODEC_PROTOBUF } from "../../vco-core/src/index.js";

const crypto = new NobleCryptoProvider();
const PRIVATE_KEY = new Uint8Array(32).fill(1);
const CREATOR_ID = deriveEd25519Multikey(PRIVATE_KEY);

function makeEnvelope(payloadByte: number): VcoEnvelope {
  return createEnvelope(
    { payload: new Uint8Array([payloadByte]), payloadType: MULTICODEC_PROTOBUF, creatorId: CREATOR_ID, privateKey: PRIVATE_KEY },
    crypto,
  );
}

let tmpDir: string;
let store: LevelDBRelayStore;

beforeEach(async () => {
  tmpDir = mkdtempSync(join(tmpdir(), "vco-relay-store-"));
  store = new LevelDBRelayStore(tmpDir);
  await store.open();
});

afterEach(async () => {
  await store.close();
  rmSync(tmpDir, { recursive: true });
});

describe("LevelDBRelayStore", () => {
  it("put and get roundtrip", async () => {
    const env = makeEnvelope(1);
    await store.put(env);
    const retrieved = await store.get(env.headerHash);
    expect(retrieved).toBeDefined();
    expect(retrieved!.payload).toEqual(env.payload);
  });

  it("has returns true after put", async () => {
    const env = makeEnvelope(2);
    expect(await store.has(env.headerHash)).toBe(false);
    await store.put(env);
    expect(await store.has(env.headerHash)).toBe(true);
  });

  it("evict removes envelope", async () => {
    const env = makeEnvelope(3);
    await store.put(env);
    await store.evict(env.headerHash);
    expect(await store.has(env.headerHash)).toBe(false);
  });

  it("allHeaderHashes yields stored hashes", async () => {
    const e1 = makeEnvelope(4);
    const e2 = makeEnvelope(5);
    await store.put(e1);
    await store.put(e2);
    const hashes: Uint8Array[] = [];
    for await (const h of store.allHeaderHashes()) hashes.push(h);
    expect(hashes.length).toBe(2);
  });

  it("PoW-sorted eviction: lowest score evicted first", async () => {
    // PoW=0 envelope evicted before PoW=4
    const plain = makeEnvelope(6);
    const powered = createEnvelope(
      { payload: new Uint8Array([7]), payloadType: MULTICODEC_PROTOBUF, creatorId: CREATOR_ID, privateKey: PRIVATE_KEY, powDifficulty: 4 },
      crypto,
    );
    await store.put(plain);
    await store.put(powered);
    const lowest = await store.lowestPowScoreHash();
    // plain envelope should have lower or equal score
    expect(lowest).toBeDefined();
  });
});
```

**Step 2: Run test to verify it fails**

```bash
npx vitest run packages/vco-relay/test/store.test.ts 2>&1 | tail -10
```

Expected: FAIL — `LevelDBRelayStore` not found.

**Step 3: Implement `packages/vco-relay/src/store.ts`**

```ts
import { ClassicLevel } from "classic-level";
import { encodeEnvelopeProto, decodeEnvelopeProto, getPowScore } from "@vco/vco-core";
import type { VcoEnvelope } from "@vco/vco-core";

export interface IRelayStore {
  open(): Promise<void>;
  put(envelope: VcoEnvelope): Promise<void>;
  get(headerHash: Uint8Array): Promise<VcoEnvelope | undefined>;
  has(headerHash: Uint8Array): Promise<boolean>;
  allHeaderHashes(): AsyncIterable<Uint8Array>;
  lowestPowScoreHash(): Promise<Uint8Array | undefined>;
  powScore(headerHash: Uint8Array): Promise<number>;
  evict(headerHash: Uint8Array): Promise<void>;
  close(): Promise<void>;
}

function toHex(bytes: Uint8Array): string {
  return Buffer.from(bytes).toString("hex");
}

function fromHex(hex: string): Uint8Array {
  return Uint8Array.from(Buffer.from(hex, "hex"));
}

function powScoreKey(score: number, hashHex: string): string {
  return `idx:${String(score).padStart(3, "0")}:${hashHex}`;
}

export class LevelDBRelayStore implements IRelayStore {
  private db: ClassicLevel<string, Uint8Array>;

  constructor(dataDir: string) {
    this.db = new ClassicLevel(dataDir, { valueEncoding: "buffer" });
  }

  async open(): Promise<void> {
    await this.db.open();
  }

  async put(envelope: VcoEnvelope): Promise<void> {
    const hashHex = toHex(envelope.headerHash);
    const score = getPowScore(envelope.headerHash);
    const encoded = encodeEnvelopeProto(envelope);
    const batch = this.db.batch();
    batch.put(`env:${hashHex}`, encoded);
    batch.put(powScoreKey(score, hashHex), new Uint8Array(0));
    await batch.write();
  }

  async get(headerHash: Uint8Array): Promise<VcoEnvelope | undefined> {
    try {
      const encoded = await this.db.get(`env:${toHex(headerHash)}`);
      return decodeEnvelopeProto(encoded);
    } catch {
      return undefined;
    }
  }

  async has(headerHash: Uint8Array): Promise<boolean> {
    try {
      await this.db.get(`env:${toHex(headerHash)}`);
      return true;
    } catch {
      return false;
    }
  }

  async *allHeaderHashes(): AsyncIterable<Uint8Array> {
    for await (const key of this.db.keys({ gte: "env:", lte: "env:~" })) {
      yield fromHex(key.slice(4));
    }
  }

  async lowestPowScoreHash(): Promise<Uint8Array | undefined> {
    for await (const key of this.db.keys({ gte: "idx:", lte: "idx:~", limit: 1 })) {
      const parts = key.split(":");
      return fromHex(parts[2]);
    }
    return undefined;
  }

  async powScore(headerHash: Uint8Array): Promise<number> {
    return getPowScore(headerHash);
  }

  async evict(headerHash: Uint8Array): Promise<void> {
    const hashHex = toHex(headerHash);
    const score = getPowScore(headerHash);
    const batch = this.db.batch();
    batch.del(`env:${hashHex}`);
    batch.del(powScoreKey(score, hashHex));
    await batch.write();
  }

  async close(): Promise<void> {
    await this.db.close();
  }
}
```

Note: `getPowScore` must be exported from `@vco/vco-core`. Check `packages/vco-core/src/pow.ts` — if it's named differently (e.g. `countLeadingZeroBits`), adjust the import.

**Step 4: Run test**

```bash
npx vitest run packages/vco-relay/test/store.test.ts 2>&1 | tail -15
```

Expected: PASS (5 tests). If `getPowScore` import fails, read `packages/vco-core/src/pow.ts` and use the correct export.

**Step 5: Export from index**

Add to `packages/vco-relay/src/index.ts`:
```ts
export * from "./store.js";
```

**Step 6: Commit**

```bash
git add packages/vco-relay/src/store.ts packages/vco-relay/test/store.test.ts packages/vco-relay/src/index.ts
git commit -m "Add LevelDB relay store with PoW-sorted eviction index"
```

---

### Task 4: Admission module

**Files:**
- Create: `packages/vco-relay/src/admission.ts`
- Create: `packages/vco-relay/test/admission.test.ts`

**Step 1: Write failing tests**

```ts
// packages/vco-relay/test/admission.test.ts
import { describe, it, expect } from "vitest";
import { createRelayAdmission } from "../src/admission.js";
import {
  VCOCore, FLAG_ZKP_AUTH, createEnvelope, encodeEnvelopeProto,
  MULTICODEC_PROTOBUF, type VcoEnvelope,
} from "../../vco-core/src/index.js";
import { NobleCryptoProvider, deriveEd25519Multikey } from "../../vco-crypto/src/index.js";
import { PowChallengePolicy } from "../../vco-sync/src/index.js";

const crypto = new NobleCryptoProvider();
const PRIVATE_KEY = new Uint8Array(32).fill(1);
const CREATOR_ID = deriveEd25519Multikey(PRIVATE_KEY);

function makeEncoded(opts: { powDifficulty?: number } = {}): Uint8Array {
  const env = createEnvelope(
    { payload: new Uint8Array([1]), payloadType: MULTICODEC_PROTOBUF, creatorId: CREATOR_ID, privateKey: PRIVATE_KEY, ...opts },
    crypto,
  );
  return encodeEnvelopeProto(env);
}

describe("createRelayAdmission", () => {
  it("admits valid signed envelope", async () => {
    const core = new VCOCore(crypto);
    const policy = new PowChallengePolicy();
    const admit = createRelayAdmission({ core, powPolicy: policy });
    const encoded = makeEncoded();
    await expect(admit(encoded)).resolves.toBeDefined();
  });

  it("rejects envelope below required PoW", async () => {
    const core = new VCOCore(crypto);
    const policy = new PowChallengePolicy({ minDifficultyProvider: () => 8 });
    const admit = createRelayAdmission({ core, powPolicy: policy });
    const encoded = makeEncoded({ powDifficulty: 0 });
    await expect(admit(encoded)).rejects.toThrow();
  });

  it("rejects ZKP_AUTH envelope with no registered verifier", async () => {
    const core = new VCOCore(crypto); // empty registry
    const policy = new PowChallengePolicy();
    const admit = createRelayAdmission({ core, powPolicy: policy });
    const zkpEnv = createEnvelope(
      {
        payload: new Uint8Array([1]),
        payloadType: MULTICODEC_PROTOBUF,
        flags: FLAG_ZKP_AUTH,
        zkpExtension: {
          circuitId: 1,
          proof: new Uint8Array(32).fill(0xab),
          proofLength: 32,
          publicInputs: new Uint8Array(16).fill(0xcd),
          inputsLength: 16,
          nullifier: new Uint8Array(32).fill(0xef),
        },
      },
      crypto,
    );
    const encoded = encodeEnvelopeProto(zkpEnv);
    await expect(admit(encoded)).rejects.toThrow();
  });
});
```

**Step 2: Run to verify failure**

```bash
npx vitest run packages/vco-relay/test/admission.test.ts 2>&1 | tail -10
```

Expected: FAIL.

**Step 3: Implement `packages/vco-relay/src/admission.ts`**

```ts
import { admitInboundEnvelope, type EnvelopeAdmissionOptions } from "@vco/vco-sync";
import type { VcoEnvelope } from "@vco/vco-core";

export type RelayAdmitFn = (encoded: Uint8Array) => Promise<VcoEnvelope>;

export function createRelayAdmission(options: EnvelopeAdmissionOptions): RelayAdmitFn {
  return (encoded) => admitInboundEnvelope(encoded, options.core!, options);
}
```

Note: Check the `EnvelopeAdmissionOptions` interface in `packages/vco-sync/src/envelope-admission.ts`. It has `core` on `VCOCore` and `powPolicy`. If `core` is not part of `EnvelopeAdmissionOptions`, pass it separately — read the source file to confirm the exact API.

**Step 4: Run tests**

```bash
npx vitest run packages/vco-relay/test/admission.test.ts 2>&1 | tail -10
```

Expected: PASS (3 tests).

**Step 5: Export**

Add to `packages/vco-relay/src/index.ts`:
```ts
export * from "./admission.js";
```

**Step 6: Commit**

```bash
git add packages/vco-relay/src/admission.ts packages/vco-relay/test/admission.test.ts packages/vco-relay/src/index.ts
git commit -m "Add relay admission module wrapping vco-sync admitInboundEnvelope"
```

---

### Task 5: Sync handler

**Files:**
- Create: `packages/vco-relay/src/sync-handler.ts`

No dedicated unit test — the sync handler is exercised by the integration test in Task 7. Just typecheck.

**Step 1: Implement `packages/vco-relay/src/sync-handler.ts`**

```ts
import type { VCOCore, VcoEnvelope } from "@vco/vco-core";
import { decodeEnvelopeProto, encodeEnvelopeProto, getPowScore } from "@vco/vco-core";
import {
  PowChallengePolicy,
  SyncRangeProofProtocol,
  type SyncMessageChannel,
} from "@vco/vco-sync";
import type { IRelayStore } from "./store.js";
import type { RelayConfig } from "./config.js";

export interface SyncHandlerOptions {
  store: IRelayStore;
  core: VCOCore;
  config: RelayConfig;
}

export async function handleSyncSession(
  channel: SyncMessageChannel,
  options: SyncHandlerOptions,
): Promise<void> {
  const { store, core, config } = options;

  const inboundPolicy = new PowChallengePolicy();
  const outboundPolicy = new PowChallengePolicy({
    defaultTtlSeconds: config.pow.windowSeconds,
    minDifficultyProvider: () => config.pow.defaultDifficulty,
  });

  const protocol = new SyncRangeProofProtocol(channel, {
    onPowChallenge: (challenge) => inboundPolicy.applyInboundChallenge(challenge),
  });

  // Issue outbound PoW challenge if difficulty > 0
  const outChallenge = outboundPolicy.createOutboundChallenge();
  if (outChallenge) {
    await protocol.sendPowChallenge(outChallenge);
  }

  // Exchange phase: receive envelopes from client
  while (true) {
    let encoded: Uint8Array;
    try {
      encoded = await channel.receive();
    } catch {
      break;
    }

    let envelope: VcoEnvelope;
    try {
      const requiredDifficulty = inboundPolicy.getRequiredDifficulty();
      envelope = decodeEnvelopeProto(encoded);
      const valid = await core.validateEnvelope(envelope, { powDifficulty: requiredDifficulty });
      if (!valid) continue;
    } catch {
      continue;
    }

    if (!await store.has(envelope.headerHash)) {
      await store.put(envelope);

      // Evict if over size limit
      if (config.maxStoreSizeMb > 0) {
        // Simple eviction: estimate — real impl would track byte count
        const lowest = await store.lowestPowScoreHash();
        if (lowest) await store.evict(lowest);
      }
    }

    // Send requested envelopes back
    const headerHashes: Uint8Array[] = [];
    for await (const h of store.allHeaderHashes()) headerHashes.push(h);
    for (const h of headerHashes) {
      const stored = await store.get(h);
      if (stored) await channel.send(encodeEnvelopeProto(stored));
    }
  }
}
```

**Step 2: Typecheck**

```bash
npm run typecheck --workspace=packages/vco-relay 2>&1 | tail -20
```

Fix any type errors.

**Step 3: Export**

Add to `packages/vco-relay/src/index.ts`:
```ts
export * from "./sync-handler.js";
```

**Step 4: Commit**

```bash
git add packages/vco-relay/src/sync-handler.ts packages/vco-relay/src/index.ts
git commit -m "Add relay sync session handler"
```

---

### Task 6: RelayServer class

**Files:**
- Create: `packages/vco-relay/src/server.ts`

**Step 1: Read the existing libp2p setup**

Read `packages/vco-transport/src/libp2p.ts` to understand how libp2p is configured in this codebase before writing server.ts.

**Step 2: Implement `packages/vco-relay/src/server.ts`**

```ts
import { createLibp2p } from "libp2p";
import { noise } from "@chainsafe/libp2p-noise";
import { yamux } from "@chainsafe/libp2p-yamux";
import { quic } from "@chainsafe/libp2p-quic";
import { identify } from "@libp2p/identify";
import { kadDHT } from "@libp2p/kad-dht";
import { NobleCryptoProvider } from "@vco/vco-crypto";
import { VCOCore } from "@vco/vco-core";
import { Libp2pSessionChannel, TransportSession } from "@vco/vco-transport";
import type { Libp2p } from "libp2p";
import type { RelayConfig } from "./config.js";
import { LevelDBRelayStore, type IRelayStore } from "./store.js";
import { handleSyncSession } from "./sync-handler.js";

const VCO_SYNC_PROTOCOL = "/vco/sync/1.0.0";

export class RelayServer {
  private readonly config: RelayConfig;
  private node?: Libp2p;
  private store?: IRelayStore;
  private readonly core: VCOCore;

  constructor(config: RelayConfig) {
    this.config = config;
    this.core = new VCOCore(new NobleCryptoProvider());
  }

  registerZkpVerifier(circuitId: number, verifier: Parameters<VCOCore["registerVerifier"]>[1]): void {
    this.core.registerVerifier(circuitId, verifier);
  }

  async start(): Promise<void> {
    const store = new LevelDBRelayStore(this.config.dataDir);
    await store.open();
    this.store = store;

    const node = await createLibp2p({
      addresses: { listen: this.config.listenAddrs },
      transports: [quic()],
      connectionEncrypters: [noise()],
      streamMuxers: [yamux()],
      services: {
        identify: identify(),
        dht: kadDHT({ clientMode: false }),
      },
      connectionManager: { maxConnections: this.config.maxConnections },
    });

    node.handle(VCO_SYNC_PROTOCOL, async ({ stream }) => {
      const session = new TransportSession({ idleTimeoutSeconds: 300 });
      const channel = new Libp2pSessionChannel(stream, { session });
      await handleSyncSession(channel, {
        store: store,
        core: this.core,
        config: this.config,
      });
    });

    await node.start();
    this.node = node;
  }

  async stop(): Promise<void> {
    await this.node?.stop();
    await this.store?.close();
  }

  get peerId() {
    return this.node?.peerId;
  }

  get multiaddrs() {
    return this.node?.getMultiaddrs() ?? [];
  }
}
```

Note: Check the exact import paths for `@chainsafe/libp2p-quic`, `@libp2p/identify`, `@libp2p/kad-dht` by looking at what versions are in package.json and their actual export structure. The API may differ — read existing usage in `packages/vco-transport/src/libp2p.ts` as reference.

**Step 3: Typecheck**

```bash
npm run typecheck --workspace=packages/vco-relay 2>&1 | tail -20
```

Fix any import or type errors before proceeding.

**Step 4: Export**

Add to `packages/vco-relay/src/index.ts`:
```ts
export * from "./server.js";
```

**Step 5: Commit**

```bash
git add packages/vco-relay/src/server.ts packages/vco-relay/src/index.ts
git commit -m "Add RelayServer class with libp2p/DHT/Identify"
```

---

### Task 7: Main entry point

**Files:**
- Create: `packages/vco-relay/src/main.ts`

**Step 1: Implement `packages/vco-relay/src/main.ts`**

```ts
import { parseArgs } from "node:util";
import { loadConfig } from "./config.js";
import { RelayServer } from "./server.js";

const { values } = parseArgs({
  options: { config: { type: "string" } },
  strict: false,
});

const configPath = values.config ?? process.env.VCO_CONFIG;
const config = loadConfig({ configPath, env: process.env as Record<string, string> });

const server = new RelayServer(config);

process.on("SIGINT", async () => { await server.stop(); process.exit(0); });
process.on("SIGTERM", async () => { await server.stop(); process.exit(0); });

server.start().then(() => {
  console.log("VCO Relay started");
  console.log("Listening on:", server.multiaddrs.map((a) => a.toString()).join(", "));
}).catch((err) => {
  console.error("Failed to start relay:", err);
  process.exit(1);
});
```

**Step 2: Typecheck**

```bash
npm run typecheck --workspace=packages/vco-relay 2>&1 | tail -10
```

**Step 3: Commit**

```bash
git add packages/vco-relay/src/main.ts
git commit -m "Add relay main entry point with SIGINT/SIGTERM handling"
```

---

### Task 8: Integration test

**Files:**
- Create: `packages/vco-relay/test/server.integration.test.ts`

**Step 1: Write the integration test**

```ts
// packages/vco-relay/test/server.integration.test.ts
import { describe, it, expect, beforeEach, afterEach } from "vitest";
import { mkdtempSync, rmSync } from "node:fs";
import { join } from "node:path";
import { tmpdir } from "node:os";
import { RelayServer } from "../src/server.js";
import { createEnvelope, encodeEnvelopeProto, decodeEnvelopeProto, MULTICODEC_PROTOBUF } from "../../vco-core/src/index.js";
import { NobleCryptoProvider, deriveEd25519Multikey } from "../../vco-crypto/src/index.js";

const crypto = new NobleCryptoProvider();
const PRIVATE_KEY = new Uint8Array(32).fill(2);
const CREATOR_ID = deriveEd25519Multikey(PRIVATE_KEY);

let tmpDir: string;
let relay: RelayServer;

beforeEach(async () => {
  tmpDir = mkdtempSync(join(tmpdir(), "vco-relay-int-"));
  relay = new RelayServer({
    listenAddrs: ["/ip4/127.0.0.1/udp/0/quic-v1"],
    dataDir: tmpDir,
    maxConnections: 10,
    pow: { defaultDifficulty: 0, maxDifficulty: 20, windowSeconds: 3600 },
    maxStoreSizeMb: 0,
  });
  await relay.start();
});

afterEach(async () => {
  await relay.stop();
  rmSync(tmpDir, { recursive: true });
});

describe("RelayServer integration", () => {
  it("starts and exposes a multiaddr", () => {
    expect(relay.multiaddrs.length).toBeGreaterThan(0);
    expect(relay.peerId).toBeDefined();
  });

  it("accepts a libp2p connection and receives an envelope", async () => {
    // Connect a second libp2p node, open a stream, send an envelope
    const { createLibp2p } = await import("libp2p");
    const { noise } = await import("@chainsafe/libp2p-noise");
    const { yamux } = await import("@chainsafe/libp2p-yamux");
    const { quic } = await import("@chainsafe/libp2p-quic");

    const client = await createLibp2p({
      transports: [quic()],
      connectionEncrypters: [noise()],
      streamMuxers: [yamux()],
    });
    await client.start();

    try {
      const relayAddr = relay.multiaddrs[0];
      const stream = await client.dialProtocol(relayAddr, "/vco/sync/1.0.0");
      const envelope = createEnvelope(
        { payload: new TextEncoder().encode("hello relay"), payloadType: MULTICODEC_PROTOBUF, creatorId: CREATOR_ID, privateKey: PRIVATE_KEY },
        crypto,
      );
      const encoded = encodeEnvelopeProto(envelope);
      await stream.sink((async function* () { yield encoded; })());
      // Relay should store and send back; just verify no throw
    } finally {
      await client.stop();
    }
  });
});
```

**Step 2: Run integration test**

```bash
npx vitest run packages/vco-relay/test/server.integration.test.ts 2>&1 | tail -20
```

Fix any failures by reading error messages carefully. Common issues:
- libp2p API differences — check `packages/vco-transport/src/libp2p.ts` for working config
- `dialProtocol` vs `dial` + stream open — check libp2p 2.x API
- Port binding on ephemeral UDP port with `/udp/0`

**Step 3: Run full package test suite**

```bash
npm run test --workspace=packages/vco-relay 2>&1 | tail -20
```

Expected: all tests pass.

**Step 4: Run full workspace typecheck**

```bash
npm run typecheck 2>&1 | tail -10
```

Expected: clean.

**Step 5: Commit**

```bash
git add packages/vco-relay/test/server.integration.test.ts
git commit -m "Add relay integration test"
```

---

### Task 9: Final cleanup and push

**Step 1: Run full workspace test**

```bash
npm run test 2>&1 | tail -30
```

Expected: all packages pass.

**Step 2: Push branch**

```bash
git push origin vco-relay
```

**Step 3: Verify**

Confirm all tests pass and the branch is up to date on the remote.
